---
permalink: '../../../../sw.js'
---

const cacheName = 'dgwltd:{% pkgVersion %}';
const themePath = '/wp-content/themes/dgwltd-theme';

// Assets to precache
const cacheFiles = [
  `${themePath}/dist/offline.html`,
  `${themePath}/dist/css/main.css`,
  `${themePath}/dist/js/app.min.js`,
  `${themePath}/dist/js/govuk-frontend-5.11.0.min.js`,
  `${themePath}/dist/icons/fav/favicon.png`,
  `${themePath}/dist/icons/fav/favicon-192x192.png`,
  `${themePath}/dist/fonts/soehne/soehne-halbfett.woff2`,
  `${themePath}/dist/fonts/soehne/soehne-dreiviertelfett.woff2`,
  `${themePath}/dist/fonts/soehne/soehne-kraftig.woff2`
];

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(cacheName).then(async cache => {
      // Add each file individually so one 404 doesn't abort the whole install
      for (const url of cacheFiles) {
        try {
          await cache.add(url);
        } catch (err) {
          // swallow the error â€“ optional: console.warn in dev
        }
      }
    })
  );
});

self.addEventListener('fetch', event => {
  // Skip anything we don't want to intercept
  if (
    event.request.method !== 'GET' ||
    /\/wp-admin\//.test(event.request.url) ||
    event.request.url.includes('preview=true') ||
    event.request.headers.get('X-Requested-With') === 'XMLHttpRequest' ||
    event.request.url.includes('admin-ajax.php')
  ) {
    return;
  }

  // For navigations (HTML page loads): network first, offline fallback
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match(`${themePath}/dist/offline.html`);
      })
    );
    return;
  }

  // For everything else (CSS/JS/fonts/images/etc.): cache first, then network
  event.respondWith(
    caches.match(event.request).then(response => {
      if (response) {
        return response;
      }
      return fetch(event.request);
    })
  );
});

self.addEventListener('activate', event => {
  event.waitUntil(
    (async () => {
      const keys = await caches.keys();
      await Promise.all(
        keys.map(key => {
          if (key !== cacheName) {
            return caches.delete(key);
          }
        })
      );
      await self.clients.claim();
    })()
  );
});