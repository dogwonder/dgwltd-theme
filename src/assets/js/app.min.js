class ShareActions extends HTMLElement {
    //From https://piccalil.li/blog/simplify-sharing-with-built-in-apis-and-progressive-enhancement/
    constructor() {
      super();
    }
  
    // Returns a url prop value or the current page url as a fallback
    get url() {
      return this.getAttribute("url") || window.location.href;
    }
  
    // Returns a title prop value or the page <title>
    get title() {
      return this.getAttribute("title") || document.title;
    }
  
    // Looks for a meta description and extracts the value if it is found. Returns an empty string if not
    get description() {
      const metaDescriptionElement = document.querySelector(
        'meta[name="description"]'
      );
  
      return metaDescriptionElement
        ? metaDescriptionElement.getAttribute("content")
        : "";
    }
  
    // Determine if this browser can use the share API
    get hasShareSupport() {
      return navigator.share;
    }
  
    // Determine if this browser can use the clipboard API
    get hasClipboardSupport() {
      return navigator.clipboard;
    }
  
    // Takes the event trigger context (<button>), triggers the share API, then passes that
    // context and alert text to the renderAlert method
    triggerShare(context) {
      navigator
        .share({
          title: this.title,
          url: this.url,
          text: this.description
        })
        .then(() => {
          this.renderAlert("Thanks!", context);
        })
        .catch((error) => console.error("Error sharing", error));
    }
  
    // Takes the event trigger context (<button>), triggers the clipboard API, then passes that
    // context and alert text to the renderAlert method
    copyToClipboard(context) {
      navigator.clipboard
        .writeText(this.url)
        .then(() => {
          this.renderAlert("Copied!", context);
        })
        .catch((error) => console.error(error));
    }
  
    // Takes message text, the event context and an optional millisecond value for clearing the
    // alert. It then renders that as a sibling (to the button) alert element *or* a local alert
    // element to this component. If neither are available, nothing happens here.
    renderAlert(text, context, clearTime = 3000) {
      const alert = context
        ? context.nextElementSibling
        : this.querySelector('[role="alert"]');
  
      if (alert) {
        alert.innerText = text;
  
        setTimeout(() => {
          alert.innerText = "";
        }, clearTime);
      }
    }
  
    // Takes an event, works out the method based on the trigger's 'data-method' attribute
    // then invokes the right event handler
    handleClick(event) {
      const method = event.currentTarget.dataset.method;
  
      switch (method) {
        case "share":
          this.triggerShare(event.currentTarget);
          return;
        case "clipboard":
          this.copyToClipboard(event.currentTarget);
          return;
      }
    }
  
    // Finds all buttons and attaches a click event to our handler
    assignEvents() {
      const buttons = this.querySelectorAll("button");
  
      if (buttons.length) {
        buttons.forEach((button) =>
          // Without doing this approach of invoking the event handler and instead
          // passing the function right in `this.handleClick` the following won't work:
          // 1. 'this' is out of scope so the trigger methods can't be found in our event handler
          // 2. event.currentTarget doesn't work which is needed to ensure the event trigger and not its children
          //    is always the correct target in our handler
          button.addEventListener("click", (event) => this.handleClick(event))
        );
      }
    }
  
    connectedCallback() {
      // No support is available for either share or clipboard APIs so we bail out here
      // and let the component's child HTML take over
      if (!this.hasShareSupport && !this.hasClipboardSupport) {
        console.log("No support so revert to MVE");
        return;
      }
  
      // Support of at least one API is available so now we render those buttons conditionally
      this.innerHTML = `
        <ul class="dgwltd-share-actions cluster" role="list">
          ${
            this.hasShareSupport
              ? `
            <li>
              <button class="button" data-method="share">Share</button>
              <div role="alert"></div>
            </li>
          `
              : ""
          }
          ${
            this.hasClipboardSupport
              ? `
            <li>
              <button class="button" data-method="clipboard">Copy URL</button>
              <div role="alert"></div>
            </li>
          `
              : ""
          }
        </ul>
  
      `;
  
      // Buttons are now rendered so we can assign the events
      this.assignEvents();
    }
  }
  
  customElements.define("share-actions", ShareActions);
import "invokers-polyfill";

const desktopWidth = 992;

export const externalLinks = () => {
  document.querySelectorAll('a[rel="external"]').forEach(link => {
    link.addEventListener('click', e => {
      e.preventDefault();
      window.open(link.href);
    });
  });
};

export const smoothScroll = () => {
  document.querySelectorAll('.scroll[href^="#"]').forEach(link => {
    link.addEventListener('click', e => {
      e.preventDefault();
      if (link.getAttribute('href') !== '#') {
        document.querySelector(link.getAttribute('href')).scrollIntoView({ behavior: 'smooth' });
      }
    });
  });
};

export const toggleNav = (button, elem, masthead) => {
  const toggleButton = document.querySelector(button);
  if (!toggleButton) return;
  const menu = document.querySelector(elem);
  const header = document.querySelector(masthead);

  window.subscribers = [];
  const defaultState = { status: 'closed', enabled: false };
  const state = new Proxy(defaultState, {
    set(state, key, value) {
      const oldState = { ...state };
      state[key] = value;
      window.subscribers.forEach(callback => callback(state, oldState));
      return state;
    }
  });

  const observer = new ResizeObserver(([{ contentRect, target }]) => {
    state.enabled = contentRect.width <= desktopWidth;
    target.setAttribute('data-enabled', state.enabled);
  });
  observer.observe(header);

  toggleButton.addEventListener('click', () => {
    const open = JSON.parse(toggleButton.getAttribute('aria-expanded'));
    state.status = open ? 'closed' : 'open';
    toggleButton.setAttribute('aria-expanded', !open);
    menu.setAttribute('status', state.status);
    header.classList.toggle('masthead-is-open');
    document.body.classList.toggle('nav-open');
    document.documentElement.style.setProperty('--submenu-offset', menu.offsetHeight + header.offsetHeight + 'px');
  });

  window.addEventListener('keydown', event => {
    if (!event.key.includes('Escape')) return;
    toggleButton.setAttribute('aria-expanded', 'false');
    header.classList.remove('masthead-is-open');
    document.body.classList.remove('nav-open');
    state.status = 'closed';
    menu.setAttribute('status', state.status);
  });
};

export const toggleTheme = () => {
  const themeSwitcher = document.getElementById("theme-switcher");
  const switchTheme = theme => {
    if (theme === "light") {
      document.documentElement.dataset.colorScheme = "light";
      localStorage.setItem("mode", "light");
      document.getElementById("theme-light").checked = true;
    } else if (theme === "dark") {
      document.documentElement.dataset.colorScheme = "dark";
      localStorage.setItem("mode", "dark");
      document.getElementById("theme-dark").checked = true;
    } else {
      delete document.documentElement.dataset.colorScheme;
      localStorage.removeItem("mode");
      document.getElementById("theme-light").checked = true;
    }
  };
  themeSwitcher.classList.add("visible");
  switchTheme(localStorage.getItem("mode"));
  document.getElementById("theme-light").addEventListener("click", () => switchTheme("light"));
  document.getElementById("theme-dark").addEventListener("click", () => switchTheme("dark"));
};

export const subMenu = (elem, masthead) => {
  const menu = document.querySelector(elem);
  if (!menu) return;
  const header = document.querySelector(masthead);
  const submenus = menu.querySelectorAll('.menu-item-has-children');

  const observer = new ResizeObserver(([{ contentRect }]) => {
    submenus.forEach(el => {
      const open = JSON.parse(el.querySelector('a').getAttribute('aria-expanded'));
      if (contentRect.width >= desktopWidth) {
        el.addEventListener("mouseenter", () => {
          document.querySelectorAll('.menu-open').forEach(nav => {
            if (nav !== el) {
              nav.classList.remove('menu-open');
              nav.querySelector('a').setAttribute('aria-expanded', 'false');
            }
          });
          el.querySelector('a').setAttribute('aria-expanded', !open);
          el.classList.toggle('menu-open');
          el.querySelector('.sub-menu').removeAttribute('hidden');
          document.body.classList.add('masthead-expanded');
        });
        el.addEventListener("mouseleave", () => {
          el.querySelector('a').setAttribute('aria-expanded', 'false');
          el.classList.remove('menu-open');
          el.querySelector('.sub-menu').setAttribute('hidden', '');
          document.body.classList.remove('masthead-expanded');
        });
        window.addEventListener('keydown', event => {
          if (!event.key.includes('Escape')) return;
          document.body.classList.remove('masthead-expanded');
          el.querySelector('a').setAttribute('aria-expanded', 'false');
          el.classList.remove('menu-open');
          el.querySelector('.sub-menu').setAttribute('hidden', '');
        });
      }
    });
  });
  observer.observe(header);

  submenus.forEach(el => {
    const activatingA = el.querySelector('a');
    const btn = document.createElement('button');
    btn.className = "button-show-subnav";
    btn.innerHTML = `<span>show sub menu for "${activatingA.text}"</span>`;
    activatingA.insertAdjacentElement('afterend', btn);

    btn.addEventListener("click", event => {
      submenus.forEach(sub => {
        if (sub.classList.contains('current-menu-item') || sub.classList.contains('current-menu-ancestor')) {
          sub.classList.remove('current-menu-item', 'current-menu-ancestor');
        }
      });
      el.classList.toggle('menu-open');
      document.querySelectorAll('.menu-open').forEach(nav => {
        if (nav !== el) nav.classList.remove('menu-open');
      });
      if (el.classList.contains('menu-open')) {
        el.querySelector('a').setAttribute('aria-expanded', "true");
        btn.setAttribute('aria-expanded', "true");
        el.querySelector('.sub-menu').removeAttribute('hidden');
      } else {
        el.querySelector('a').setAttribute('aria-expanded', "false");
        btn.setAttribute('aria-expanded', "false");
        el.querySelector('.sub-menu').setAttribute('hidden', '');
      }
      event.preventDefault();
    });
  });
};

export const cardClick = elem => {
  document.querySelectorAll(elem).forEach(card => {
    const link = card.querySelector('.dgwltd-card__link');
    if (!link) return;
    card.addEventListener("click", event => {
      if (!window.getSelection().toString()) {
        window.location = link.href;
      }
    });
  });
};

export class TextareaHandler {
  constructor(elem) {
    document.querySelectorAll(elem).forEach(textarea => {
      textarea.setAttribute('rows', 4);
      this.update(textarea);
    });
  }
  isScrolling(textarea) {
    return textarea.scrollHeight > textarea.clientHeight;
  }
  grow(textarea) {
    let clientHeight = textarea.clientHeight;
    let rows = this.rows(textarea);
    while (this.isScrolling(textarea)) {
      rows++;
      textarea.rows = rows;
      const newClientHeight = textarea.clientHeight;
      if (newClientHeight === clientHeight) break;
      clientHeight = newClientHeight;
    }
  }
  shrink(textarea) {
    let clientHeight = textarea.clientHeight;
    const minRows = parseInt(textarea.dataset.minRows);
    let rows = this.rows(textarea);
    while (!this.isScrolling(textarea) && rows > minRows) {
      rows--;
      textarea.rows = Math.max(rows, minRows);
      if (textarea.clientHeight === clientHeight) break;
      if (this.isScrolling(textarea)) {
        this.grow(textarea);
        break;
      }
    }
  }
  update(textarea) {
    if (this.isScrolling(textarea)) {
      this.grow(textarea);
    } else {
      this.shrink(textarea);
    }
  }
  rows(textarea) {
    return textarea.rows || parseInt(textarea.dataset.minRows);
  }
}

// Init
// import { externalLinks, smoothScroll } from './app.js';

// On load
document.addEventListener("DOMContentLoaded", () => {
  externalLinks();
  smoothScroll();
  toggleNav('#nav-toggle', '#nav-primary', '#masthead');
  toggleTheme();
  subMenu('#nav-primary', '#masthead');
  cardClick('.dgwltd-card');
  new TextareaHandler('textarea');
});